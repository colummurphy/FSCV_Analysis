%re-convert LFP trial-split data as generated by getFSCV.m
%spectral sub and downsample to smaller sized files
function reconvertfscv2(pathdir,chs,varargin)
%run chronicXXchconfig first to load ncschannels for that session
%get csc #'s & their categories from channel labels provided for given session
%ncschannels={'p2-p3','p2','p3','p3-p5','p5','pl1-pl2','pl1','pl2','cl1','cl1-cl4','cl4',...
% %   'cl5','cl4-cl5','s6','s5','s6-s5','s4','s5-s4','s3','s2','s3-s2',...
%    's1','s2-s1','eyed','eyex','lickx','pulse'};          %chronic 38

ncschannels=chs;
d=dir(pathdir);
cd(pathdir);
filenames={d.name};
targfiles=strfind(filenames,'fscv_multi');
processfiles=find(~cellfun(@isempty,targfiles));
%contains function does not work for 2013 for cells 
files=filenames(processfiles);

patra_map_bipolar;            %get default csc_map

argnum=1;
while argnum<=length(varargin)
    switch varargin{argnum}
        case 'map'
            %user provided csc map
            argnum=argnum+1;
            csc_map=varargin{argnum};
    end
    argnum=argnum+1;
end

[lfpchs,bipolarchs,otherchs,sumchs]=getcscids(ncschannels,csc_map);

%lfpchs=[3, 4, 5, 8,9, 11, 14, 15, 27:32];    %chronic38
%bipolarchs={[3, 4], [4, 5],[8,9],[11, 14], [14, 15], [27, 28], [28, 29], [30, 31], [31 32]};
%otherchs=[33:35,39:41,42];   %eye, lick, pulse
%sumchs=[39:41];            %sum up signals from lick accel x,y,z data
selectCSC=[lfpchs otherchs];
filtPhys=[0 100];        %filter physiological signals in this range
cscNames={};
dsN=30;         %factor for downsampling

%get directory for csc data & make new directory for processed data
%files = uigetdir2(pwd,'Select multifscv trial-split recording files'); 
sep2=findstr(filesep,files{1});
%PathName=files{1}(1:sep2(end));
pathSave=[pathdir(1:end-1) '_pro\'];
pathSave=[pathdir(1:end-1) '_pro' filesep];
%pathDown=[PathName(1:end-1) '_downsampled\'];
if ~isdir(pathSave) 
    status = mkdir(pathSave)
  %  status2 = mkdir(pathDown)
end

load(files{1});
samplingFreq=getSampleRate(tsLFP);
%smoothWindow=round(samplingFreq*0.0384);       %.0384 s = .5 cycle beta 
digids=regexp(nlxFileNames,'\d');       %assume csc chs are same for all files
nlxIDs=[];
for ii=1:length(nlxFileNames)
    ab=nlxFileNames{ii};
    nlxIDs(ii)=str2num(ab(digids{ii}));
end

alreadydsts=0;
%%
for ifile=1:size(files,2)
    disp(['processing file # ' ...
        num2str(ifile) '/' num2str(size(files,2))]);
    load(files{ifile});
    filename=files{ifile};

    alreadydsts=0;
    ts=[];
    samples={};
    samples_dsonly={};      %unprocessed, just downsamples only like eye
    renlxFileNames={};
    sumchsflag=0;        %already summed sum ch
    bipolarFlag=0;      %already processed bipolar pair flag
    saveID=1;           %save channel id (ie. added chs will be saved because of created bipolar chs)
    bchs=[bipolarchs{:}];       %reset bipolar each file, since will remove from this list as processed

    %cycle all targeted channels
    for ich=1:size(selectCSC,2)
        %get chid of stored nlx samples as matched to targeted ich
        chid=find(nlxIDs==selectCSC(ich));
        %get new ch name if stored in different order
        renlxFileNames{saveID}=nlxFileNames{chid};
        if ~ismember(selectCSC(ich),otherchs)
            %is LFP signal, process
            %need to spectral sub/deglitch, etc.
            samplestemp=spectralSub2(samplesLFP{chid},ceil(samplingFreq)); %spectral subtraction
            %samplesdg=deglitchDiff(samplestemp, 30);       %deglitch with
            %30 pt padding, line interpolation
            samplesdg=deglitchandsmooth(samplestemp, 20);       %deglitch with 20 pt padding & smooth/not just line
            %downsample processed signal
            subsamples = downsampleSingleBatch(samplesdg,dsN);
            if alreadydsts==0
                %downsample timestamps once per file
                ts = reshape(tsLFP(1:dsN:end), 1, []);
                alreadydsts=1;
            end
            %figure check
            %{
            fig2=figure;
            set(fig2,'color',[1 1 1], 'units','pixels','position',[100 100 800 400]);
            hold on;
            plot(tsLFP-tsLFP(1),samplesLFP{chid})
            xlabel('time (s)')
            ylabel('amplitude (V)')
            title('LFP (time-domain)');
            ylim([-2e-4 2e-4]);
            xlim([35 36]);
           % plot(tsLFP-tsLFP(1),samplestemp);
            plot(ts-tsLFP(1),subsamples);
            samplesfilt=filterLFP(subsamples,samplingFreq/dsN,[13 36]);
            %if want envelop for this channel, envelope
            samplesfiltp=samplesfilt.^2;   %get power V^2
            samplesfiltps=smoothwin(samplesfiltp,round(samplingFreq/dsN*0.0384));   %smoothing
            yyaxis right;
            plot(ts-tsLFP(1),samplesfiltp,'linewidth',1,'linestyle','--','color',[.6 .6 .6]);
                   plot(ts-tsLFP(1),samplesfiltps,'linewidth',1,'color',[.4 .4 .4]);
             %}
            %store processed/downsampled LFP
            samples{saveID}=subsamples;
            %store unprocessed/downsampled LFP
        elseif ismember(selectCSC(ich),sumchs) && sumchsflag==0
            %if summing channel for lick xyz
            %take absolute mag of each x,y,z signal component & sum
            chidsum=[];
            subsamples=abs(samplesLFP{chid});
            for ichsum=1:length(sumchs)-1
                %summate with next 2 consecutive channels y/z lick
                %store just downsampled signals for channels y/z
                chidsum=find(nlxIDs==selectCSC(ich+ichsum));
                subsamples=subsamples+abs(samplesLFP{chidsum});
                samples_dsonly{saveID+ichsum}=downsampleSingleBatch(samplesLFP{chidsum},dsN);
                %save raw data for other y/z channels 
                %skip repeating this in next cycles because of sumchsflag
                samples{saveID+ichsum}=samples_dsonly{saveID+ichsum};
            end
            %process summed samples
            subsamples=filterLFP(subsamples,samplingFreq,filtPhys);
            %save summed & processed samples
            samples{saveID}=downsampleSingleBatch(subsamples,dsN);
            sumchsflag=1;        %turn on flag so do not process other sum channels
        elseif ismember(selectCSC(ich),otherchs) && ~ismember(selectCSC(ich),sumchs)
            %just downsample if not LFP signal (ie. pulse/eye diam)
            samples{saveID}=downsampleSingleBatch(samplesLFP{chid},dsN);
        end
        %if bipolar selected channel, subtract channels & process LFP
        %csc naming convention here is to use 0 between ch #'s
        %eg 2-3 is csc203.ncs
        if ismember(selectCSC(ich),bchs)
            saveID=saveID+1; %increment idx to save created samples
            bid=find(selectCSC(ich)==bchs);
            chid=find(nlxIDs==bchs(bid));
            %assume next bipolar listed ch is the one to subtract, skip next cycle
            chid2=find(nlxIDs==bchs(bid+1));        
            %create bipolar save name
            renlxFileNames{saveID}=['csc' num2str(bchs(bid)) '0' ...
                 num2str(bchs(bid+1)) '.ncs'];
            samplesbipolar=samplesLFP{chid}-samplesLFP{chid2};
            %same processing for LFP
            samplestemp=spectralSub2(samplesbipolar,samplingFreq); %spectral subtraction
            samplesdg=deglitchandsmooth(samplestemp, 30);       %deglitch with 30 pt padding
            subsamples = downsampleSingleBatch(samplesdg,dsN);
            if alreadydsts==0
                %downsample timestamps once per file
                ts = reshape(tsLFP(1:dsN:end), 1, []);
                alreadydsts=1;
            end  
            samples{saveID}=subsamples;
            bchs=bchs(3:end);       %take out first pair from list, since processed
        end
        saveID=saveID+1;
    end
    
    %save processed data in new paths with original variables
    samplesLFP=samples;
    tsLFP=ts;           %store signals in original variable names for comptability with other funcs.
    nlxFileNames=renlxFileNames;
    save([pathSave, filename],'fscv','samplesLFP','tsLFP','NlxEventTTL','NlxEventTS','nlxFileNames')
    disp(['saved to: ' pathSave filename]);
end


end

